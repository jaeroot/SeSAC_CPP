// 단축키 꿀팁
// ALT + 좌클릭 드래그 (세로 기준으로 잡음)

// 
// #이 붙으면 전처리기
// 전처리 : 컴파일 하기 전에 우선적으로 처리하는 것
// 전처리된 결과물을 바탕으로 컴파일을 진행함

// 
// 프로그램 실행 과정
// 1. 컴파일(번역, 고수준 언어 -> 저수준 언어, ex. C++ -> 어셈블리어 -> 기계어(바이너리 코드))
// 2. 링크(링커가 여러 파일들을 묶음)
// 3. 컴파일을 통해 실행 파일을 만듦
// 4. 실행 시 코드를 메모리에 올리고, cpu가 메모리를 읽어서 동작시킴

#include <iostream>		// iostream에는 입출력에 관련된 기능들이 들어가 있음

int main()
{
	//
	// napespace : 중복으로 인한 충돌을 피하기 위해 소속을 정해두는 것
	// 범위 지정 연산자 :: (스코프 연산자)
	// using namespace 가급적 쓰지 말자

	//
	// \는 특수문자 표현 시 사용
	// \t : Tab, \n : 한 줄 개행
	std::cout << "Hello C++!" << std::endl;
	printf("Hello C!\n");		// 가변인자??


	// 
	// 용량의 최소 단위 : bit
	// 1bit는 0 또는 1을 저장할 수 있음
	// bit가 한 개씩 늘어날수록 저장할 수 있는 범위는 2의 제곱만큼 늘어남
	// 1byte = 8bit
	// 1kbyte = 1024byte
	// ... (1024 동일)

	/*
	변수 : 값이 변할 수 있음

	signed : 부호를 가질 수 있음
	unsigned : 부호를 가질 수 없음
	명시하지 않을 시, 기본으로 signed

	MSB는 부호 비트
	unsigned는 부호 비트가 없음

	실수는 부동소수점 방식으로 부호비트, 지수부, 가수부를 나눠서 표현

	참/거짓에서 0은 false, 나머지는 true로 인식

	실수 사용 시 뒤에 f를 붙이면 float타입, 그냥 쓰면 double 타입이 됨

	문자 하나 저장 시 '', 문자열 저장시 ""

	타입		|	크기		|	종류		|			표현범위				|	unsigned
	bool	|	1byte	|	참/거짓	|	false(0) ~ true(1)
	char	|	1byte	|	문자		|	-128 ~ 127					|	0 ~ 255
	short	|	2byte	|	정수		|	-32768 ~ 32767				|	0 ~ 65535
	int		|	4byte	|	정수		|	-2147483648 ~ 2147483647	|	0 ~ 0xffffffff
	__int64	|	8byte	|	정수		|
	float	|	4byte	|	실수		|
	double	|	8byte	|	실수		|

	변수 선언 규칙
	첫 글자 숫자 x, 특수문자는 _만 가능

	printf 출력 시 형식 지정자
	%d : 정수, %f : 실수, %s : 문자열, %c : 문자, %I64d : __int64

	

	상수 : 값이 변할 수 없음
	변수 타입 앞에 const 키워드를 붙이면 상수가 됨
	상수는 선언 시 초기화가 같이 이루어져야 함
	*/

	__int64 number = 0xffffffff;
	std::cout << number;
	printf("%I64d", number);

	// 형 변환
	// 일시적으로 다른타입으로 인식하는 기능
	// 암시적 형변환		int number = 3.14f;
	// 명시적 형변환		int number = (int)3.14f;

	
	/*
	연산자
	사칙 연산자 : +, -, *, /, %
	나머지 연산은 정수에서 사용
	나눗셈 연산에서 실수 결과를 얻고 싶다면, 피연산자 둘 중 하나는 실수여야 함
	연산자 우선순위 : *, / %  >  +, -


	관계 연산자 : ==, !=, >, <, >=, <=
	값 대 값을 연산하여 결과로 참/거짓이 나오게 됨


	논리 연산자 : AND(&&), OR(||), NOT(!)
	참/거짓 대 참/거짓을 해서 결과로 참/거짓이 나오게 됨

	A	B	AND	 OR
	0	0	0	 0
	1	0	0	 1
	0	1	0	 1
	1	1	1	 1

	A	NOT
	0	1
	1	0


	증감 연산자 : ++, --


	연산자 줄임 표현 : +=, -=, *=, /=, %=


	2진수(0b101111011) : 0 ~ 1 사이의 숫자 집합
	10진수(379) : 0 ~ 9 사이의 숫자 집합
	16진수(0x17b) : 0 ~ 15 사이의 숫자 집합, 10 ~ 15 사이의 값은 a ~ f로 표현

	비트단위 논리연산자 : AND(&), OR(|), NOT(~), XOR(^)
	값 대 값을 연산하여 결과로 값이 나오게 됨
	연산하는 값들을 2진수로 변환한 후, 2진수 각 자리별로 논리연산을 수행하여 최종 결과가 나옴
	XOR을 두 번 수행하면 원래 값으로 돌아옴 (toggle 기능)
	~사용 시 비트의 빈 공간도 전부 ~연산이 수행됨
	~는 signed일 경우 0을 기준으로 대칭되는 반대의 값이 나옴

	A	B	XOR
	0	0	0
	1	0	1
	0	1	1
	1	1	0


	비트단위 쉬프트 연산자 : <<, >>

	0b1010 << 2 = 0b101000, 오른쪽에 0을 2개 붙임
	<< 연산 : 빠른 곱셈, << n을 할 경우 2^n만큼 곱함, 부호 비트는 밀어내지 않음(그대로 둠)

	0b1010 >> 2 = 0b10, 오른쪽 2개 제거
	>> 연산 : 빠른 나눗셈, >> n을 할 경우 2^n만큼 나눔

	*/

	return 0;
}